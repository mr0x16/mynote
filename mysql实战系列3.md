# mysql实战系列3

## 深入浅出索引(上)

1. 索引常见的模型

* 目的：提高查询效率
* 分类：哈希表、有序数组、搜索树

> 哈希表：以k-v存储数据的结构，思路是将值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。当多个key值经过哈希函数的换算，对应同一个值的情况时，会在对应值出拉出一个链表。**这种结构适用于只有等值查询的场景**
>
> 有序数组：一个有序的数组，假设使用用身份证查找个人信息的列子，身份证号没有重复，数组按照身份证号递增**在等值查询和范围查询场景中性能都非常优秀**，等值查询使用二分查找的话，时间复杂度是O(log(N))。当在[ID_X, ID_Y]中进行范围查找时，可以先用二分法找到大于等于ID_X的第一个User，然后向右遍历，知道查到第一个大于ID_Y的身份证号，退出循环。*只考虑查询效率的话，有序数组是最好的数据结构*，**但是插入一条记录需要挪动后面的所有记录，成本太高**
>
> 二叉搜索树：每个节点的左节点小于父节点，父节点有小于右节点。为了保证查询的时间复杂度是O(log(N))，需要保证这棵树是平衡二叉树。*这种数据结构查询效率较高，但是实际山大多数的数据库存储却并不使用二叉树，其原因是，索引不止存在内存中，还要写在磁盘上*。所以一般使用N叉数，在InnoDB中，这个N大致是1200

数据库底层存储的核心就是基于数据模型，当遇到一个新的数据库的时候需要考虑他的数据模型，才能从理论上分析出这个数据库的适用场景。

在Mysql中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引工作方式并不一样。

2. InnoDB的索引模型

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为*索引组织表*。InnoDB中使用B+数索引模型，所以数据都是存储在B+树中的。(每个索引在InnoDB里面对应一棵B+树)。

主键索引的叶子节点存的是整行数据，在InnoDB里，主键索引也被称为聚簇索引(clustered index)。

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引。

那么，基于主键索引的查询和基于非主键的查询有什么区别呢？

假设有建表语句

```mysql
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```

* 如果语句是`select * from T where ID = 500`，即主键查询方式，则只需要搜索ID这棵B+树；
* 如果语句是`select * from T where k = 5`，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次，这个过程称为*回表*

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

3. 索引维护

根据B+索引树的算法，当插入的数据页已经满了的时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称之为**页分裂**。在这种情况下，性能会受到影响。

除了性能外，页分裂操作还影响数据的利用率。

当相邻的两个页由于删除了数据，利用率很低后，会将数据页做合并。

**自增主键**什么时候用？

从性能和存储空间方面，自增主键往往是更合理的选择。

但是有些业务场景有这样的需求：

1. 只有一个索引；
2. 该索引必须是唯一索引；

## 深入浅出索引(下)

1. 覆盖索引

建表如下：

```mysql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

执行如下语句`select * from T where k between 3 and 5`，需要查询k索引树的3条记录，回表两次。

如果执行`select ID from T where k between 3 and 5`，这时只需要查ID值，而ID值已经在k搜索树上了，因此可以直接提供查询结果，不需要回表，在这个查询里，索引k的树已经“覆盖了”查询需求，这种情况称之为"索引覆盖"。

2. 最左前缀原则

**B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。**

索引项是按照索引定义里面出现的字段顺序排列的。

不止全部索引，只要满足最左前缀就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

那么，在建立联合索引的时候，可以通过安排联合索引内的字段顺序，来达到少维护一个索引的目的，那么这个顺序就是最为合理的。

3. 索引下推

MySQL5.6以后带来的特性，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
# mysql实战系列3

## 深入浅出索引(上)

1. 索引常见的模型

* 目的：提高查询效率
* 分类：哈希表、有序数组、搜索树

> 哈希表：以k-v存储数据的结构，思路是将值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。当多个key值经过哈希函数的换算，对应同一个值的情况时，会在对应值出拉出一个链表。**这种结构适用于只有等值查询的场景**
>
> 有序数组：一个有序的数组，假设使用用身份证查找个人信息的列子，身份证号没有重复，数组按照身份证号递增**在等值查询和范围查询场景中性能都非常优秀**，等值查询使用二分查找的话，时间复杂度是O(log(N))。当在[ID_X, ID_Y]中进行范围查找时，可以先用二分法找到大于等于ID_X的第一个User，然后向右遍历，知道查到第一个大于ID_Y的身份证号，退出循环。*只考虑查询效率的话，有序数组是最好的数据结构*，**但是插入一条记录需要挪动后面的所有记录，成本太高**
>
> 二叉搜索树：每个节点的左节点小于父节点，父节点有小于右节点。为了保证查询的时间复杂度是O(log(N))，需要保证这棵树是平衡二叉树。*这种数据结构查询效率较高，但是实际山大多数的数据库存储却并不使用二叉树，其原因是，索引不止存在内存中，还要写在磁盘上*。所以一般使用N叉数，在InnoDB中，这个N大致是1200

数据库底层存储的核心就是基于数据模型，当遇到一个新的数据库的时候需要考虑他的数据模型，才能从理论上分析出这个数据库的适用场景。

在Mysql中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引工作方式并不一样。

2. InnoDB的索引模型

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为*索引组织表*。InnoDB中使用B+数索引模型，所以数据都是存储在B+树中的。(每个索引在InnoDB里面对应一棵B+树)。

主键索引的叶子节点存的是整行数据，在InnoDB里，主键索引也被称为聚簇索引(clustered index)。

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引。

那么，基于主键索引的查询和基于非主键的查询有什么区别呢？

假设有建表语句

```mysql
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```

* 如果语句是`select * from T where ID = 500`，即主键查询方式，则只需要搜索ID这棵B+树；
* 如果语句是`select * from T where k = 5`，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次，这个过程称为*回表*

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

3. 索引维护

根据B+索引树的算法，当插入的数据页已经满了的时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称之为**页分裂**。在这种情况下，性能会受到影响。

除了性能外，页分裂操作还影响数据的利用率。

当相邻的两个页由于删除了数据，利用率很低后，会将数据页做合并。

**自增主键**什么时候用？

